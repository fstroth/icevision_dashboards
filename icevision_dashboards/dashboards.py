# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/dashboards.ipynb (unless otherwise specified).

__all__ = ['ObjectDetectionDatasetOverview', 'ObjectDetectionDatasetComparison', 'ObjectDetectionDatasetGenerator',
           'ObjectDetectionResultOverview', 'time_list']

# Cell
from typing import Union, Optional, List
from abc import abstractmethod, ABC
from math import ceil, floor

from bokeh.plotting import show, output_notebook, gridplot, figure
from bokeh.models.widgets import DataTable, TableColumn, HTMLTemplateFormatter
from bokeh.models import ColumnDataSource, HoverTool, Title
from bokeh import events

import panel as pn
import panel.widgets as pnw
import numpy as np
import pandas as pd

from .core.dashboards import *
from .plotting import *
from .core.data import *
from .data import *
from .plotting.utils import toggle_legend_js

# Cell
class ObjectDetectionDatasetOverview(DatasetOverview):
    DESCRIPTOR_DATA = "data"
    DESCRIPTOR_STATS_DATASET = "stats_dataset"
    DESCRIPTOR_STATS_IMAGES = "stats_image"
    DESCRIPTOR_STATS_ANNOTATIONS = "stats_class"

    # change these
    IMAGE_IDENTIFIER_COL = "filepath"
    ANNOTATON_LABEL_COL = "label"
    OBJECTS_PER_IMAGE_COL = "num_annotations"
    AREA_COL = "area"

    def _generate_datset_stats_tab(self):
        dataset_overview_table = table_from_dataframe(getattr(self.dataset, self.DESCRIPTOR_STATS_DATASET), width=self.width, height=self.height//7)
        images_overview_table = table_from_dataframe(getattr(self.dataset, self.DESCRIPTOR_STATS_IMAGES), width=self.width, height=self.height//7)
        classes_overview_table = table_from_dataframe(getattr(self.dataset, self.DESCRIPTOR_STATS_ANNOTATIONS), width=self.width, height=self.height//4)

        class_occurances = self.dataset.data.groupby("label").count()["id"]
        class_occurance_barplot = barplot(counts=class_occurances.values, values=np.array(class_occurances.index), bar_type="vertical", height=(self.height//5)*2)

        return pn.Column("<b>Dataset stats</b>", dataset_overview_table, "<b>Image stats</b>", images_overview_table, "<b>Class stats</b>", classes_overview_table, pn.Row(class_occurance_barplot, align="center"))

    def _generate_annotations_tab(self):
        plot_size = floor(min(self.height, self.width)*0.45)
        # mixing of classes
        mixing_matrix_classes_in_images = utils.calculate_mixing_matrix(getattr(self.dataset, self.DESCRIPTOR_DATA), self.IMAGE_IDENTIFIER_COL, self.ANNOTATON_LABEL_COL)
        self.class_mixing_matrix_plot = pn.Column("<b>Class mixing</b>", heatmap(mixing_matrix_classes_in_images, "row_name", "col_name", "values", width=plot_size, height=plot_size), height=self.height)
        # number of object per image, stacked hist
        self.classes_for_objects_per_image_stacked_hist = pn.Column(
            "<b>Objects per Image</b>",
            stacked_hist(getattr(self.dataset, self.DESCRIPTOR_DATA), self.OBJECTS_PER_IMAGE_COL, self.ANNOTATON_LABEL_COL, "Objects per Image", width=plot_size, height=plot_size)
        )
        # categorical overview
        self.categorical_2d_histogram = categorical_2d_histogram_with_gui(
            getattr(self.dataset, self.DESCRIPTOR_DATA),
            category_cols=["label", "num_annotations", "width", "height"],
            hist_cols=["num_annotations", "area", "area_normalized", "bbox_ratio", "bbox_xmin", "bbox_xmax", "bbox_ymin", "bbox_ymax", "width", "height"],
            height=self.height//2, width=self.width//2
        )
        # ratio distribution
        grid =  pn.GridSpec(ncols=2,nrows=2, width=self.width, height=self.height, align="center")
        grid[0,0] = self.class_mixing_matrix_plot
        grid[1,0] = self.classes_for_objects_per_image_stacked_hist
        grid[:,1] = pn.Column(self.categorical_2d_histogram, align="center")
        return grid

    def _generate_gallery_tab(self):
        return pn.Column(Gallery(self.dataset, "data", "filepath", ["num_annotations", "width", "height", "label", "area", "bbox_ratio", "bbox_width", "bbox_height"], height=self.height).show(), align="center", sizing_mode="stretch_both")

    def build_gui(self):
        dataset_tab = super()._generate_dataset_tab()
        dataset_stats_tab = self._generate_datset_stats_tab()
        annotations_tab = self._generate_annotations_tab()
        gallery_tab = self._generate_gallery_tab()
        self.gui = pn.Tabs(("Dataset stats", dataset_stats_tab), ("Annotations", annotations_tab), ("Gallery", gallery_tab), ("Dataset", dataset_tab), align="start")

# Cell
class ObjectDetectionDatasetComparison(DatasetComparison):
    DESCRIPTOR_DATA = "data"
    DESCRIPTOR_STATS_DATASET = "stats_dataset"
    DESCRIPTOR_STATS_IMAGES = "stats_image"
    DESCRIPTOR_STATS_ANNOTATIONS = "stats_class"

    # change these
    IMAGE_IDENTIFIER_COL = "filepath"
    ANNOTATON_LABEL_COL = "label"
    OBJECTS_PER_IMAGE_COL = "num_annotations"
    AREA_COL = "area"

    def _generate_dataset_tab(self):
        overview_table = table_from_dataframe(self._get_descriptor_for_all_datasets(self.DESCRIPTOR_DATA), width=floor(self.width/2), height=self.height)
        return pn.Row(*overview_table)

    def _generate_datset_stats_tab(self):
        dataset_overview_table = table_from_dataframe(self._get_descriptor_for_all_datasets(self.DESCRIPTOR_STATS_DATASET), width=floor(self.width/2), height=self.height//7)
        images_overview_table = table_from_dataframe(self._get_descriptor_for_all_datasets(self.DESCRIPTOR_STATS_IMAGES), width=floor(self.width/2), height=self.height//7)
        classes_overview_table = table_from_dataframe(self._get_descriptor_for_all_datasets(self.DESCRIPTOR_STATS_ANNOTATIONS), width=floor(self.width/2), height=self.height//4)

        class_occurances_values = [dataset.data.groupby("label").count()["id"].values for dataset in self.datasets]
        class_occurances_index = [np.array(dataset.data.groupby("label").count()["id"].index) for dataset in self.datasets]
        class_occurance_barplot = barplot(counts=class_occurances_values, values=class_occurances_index, bar_type="vertical", height=(self.height//5)*2, width=floor(self.width/2))

        dublication_data = {dataset.name if dataset.name is not None else "Dataset_"+str(index): [getattr(dataset, self.DESCRIPTOR_DATA).duplicated().sum()] for index, dataset in enumerate(self.datasets)}
        dublication_data["All"] = pd.concat(self._get_descriptor_for_all_datasets(self.DESCRIPTOR_DATA)).duplicated().sum()
        dublication_df = pd.DataFrame(dublication_data)
        dublication_overview = table_from_dataframe(dublication_df)

        return pn.Column(
            "<b>Dublications</p>", pn.Row(dublication_overview),
            "<b>Dataset stats</b>", pn.Row(*dataset_overview_table),
            "<b>Image stats</b>", pn.Row(*images_overview_table),
            "<b>Class stats</b>", pn.Row(*classes_overview_table),
            pn.Row(*class_occurance_barplot, align="center")
        )

    def _generate_annotations_tab(self):
        plot_size = min(floor(self.width/len(self.datasets)), floor(self.height/2))
        link_plots_checkbox = pnw.Checkbox(name="Link plot axis", value=False)

        @pn.depends(link_plots_checkbox.param.value)
        def _mixing_plots(link_plots):
            # mixing of classes
            mixing_matrix_classes_in_images = [utils.calculate_mixing_matrix(dataset, self.IMAGE_IDENTIFIER_COL, self.ANNOTATON_LABEL_COL) for dataset in self._get_descriptor_for_all_datasets(self.DESCRIPTOR_DATA)]
            class_mixing_matrix_plot = pn.Row("<b>Class mixing</b>", *heatmap(mixing_matrix_classes_in_images, "row_name", "col_name", "values", link_plots=link_plots, width=plot_size, height=plot_size))
            # number of object per image, stacked hist
            classes_for_objects_per_image_stacked_hist = pn.Row(
                "<b>Objects per Image</b>",
                *stacked_hist(self._get_descriptor_for_all_datasets(self.DESCRIPTOR_DATA), self.OBJECTS_PER_IMAGE_COL, self.ANNOTATON_LABEL_COL, "Objects per Image", link_plots=link_plots, width=plot_size, height=plot_size)
            )
            return pn.Column(link_plots_checkbox, class_mixing_matrix_plot, classes_for_objects_per_image_stacked_hist)

        # categorical overview
        self.categorical_2d_histogram = categorical_2d_histogram_with_gui(
            self._get_descriptor_for_all_datasets(self.DESCRIPTOR_DATA),
            category_cols=["label", "num_annotations", "width", "height"],
            hist_cols=["num_annotations", "area", "area_normalized", "bbox_ratio", "bbox_xmin", "bbox_xmax", "bbox_ymin", "bbox_ymax", "width", "height"],
            height=floor(plot_size*1.5), width=floor(plot_size*1.5)
        )
        return pn.Column(_mixing_plots, self.categorical_2d_histogram, align="center")

    def _generate_gallery_tab(self):
        return pn.Row(*[Gallery(dataset, "data", "filepath", ["num_annotations", "width", "height", "label", "area", "bbox_ratio", "bbox_width", "bbox_height"], width=floor(self.width/len(self.datasets))).show() for dataset in self.datasets], align="start", sizing_mode="stretch_both")

    def build_gui(self):
        dataset_tab = self._generate_dataset_tab()
        dataset_stats_tab = self._generate_datset_stats_tab()
        annotations_tab = self._generate_annotations_tab()
        gallery_tab = self._generate_gallery_tab()
        self.gui = pn.Tabs(("Dataset stats overview", dataset_stats_tab), ("Annotations overivew", annotations_tab), ("Gallery", gallery_tab), ("Dataset overview", dataset_tab), align="start")

# Cell
class ObjectDetectionDatasetGenerator(DatasetGenerator):
    DESCRIPTOR_STATS = "stats_dataset"
    DATASET_OVERVIEW = ObjectDetectionDatasetOverview
    DATASET_FILTER_COLUMNS = ["width", "height", "label", "area_normalized", "bbox_ratio", "bbox_width", "bbox_height", "num_annotations"]

# Cell
time_list = []

class ObjectDetectionResultOverview(Dashboard):
    def __init__(self, dataset):
        self.dataset= dataset
        super().__init__()

    def build_gui(self):
        self.loss_tab = self.build_loss_tab()
        self.ap_tab = self.build_precision_recall_tab()
        self.gui = pn.Tabs(("Loss", self.loss_tab), ("Precision-Recall", self.ap_tab))
        # self.gui = None

    def show(self):
        return self.gui

    def show_loss_tab(self):
        return self.loss_tab

    def show_ap_tab(self):
        return self.ap_tab

    def build_loss_tab(self):
        # loss hists
        bins_input = pnw.IntInput(name="Bins", start=1, end=100, value=10)

        @pn.depends(bins_input.param.value)
        def loss_hists(bins):
            unique_losses = self.dataset.base_data[["filepath", "loss_classifier", "loss_box_reg", "loss_objectness", "loss_rpn_box_reg", "loss_total"]].drop_duplicates()
            hist_line = plots_as_matrix(
                histogram(
                    [unique_losses[loss] for loss in ["loss_total", "loss_classifier", "loss_box_reg", "loss_objectness", "loss_rpn_box_reg"]],
                    title=["loss_total", "loss_classifier", "loss_box_reg", "loss_objectness", "loss_rpn_box_reg"],
                    bins=bins, linked_axis=False), 5, 1, width=1500, height=200
            )
            return hist_line
        pn.Column(bins_input, loss_hists)

        axis_cols = ['score', 'area_normalized', 'area', 'bbox_ratio', 'bbox_width', 'bbox_height', 'num_annotations', 'loss_classifier', 'loss_box_reg', 'loss_objectness', 'loss_rpn_box_reg', 'loss_total', 'width', 'height']
        scatter_overview = scatter_plot_with_gui(
            self.dataset.base_data[self.dataset.base_data["is_prediction"] == True],
            x_cols=axis_cols[1:] + [axis_cols[0]],
            y_cols=axis_cols,
            color_cols=["label", "num_annotations", "filename"]
        )

        cat_2d_hist = categorical_2d_histogram_with_gui(
            self.dataset.base_data[self.dataset.base_data["is_prediction"] == True],
            category_cols=["label", "num_annotations", "filename"],
            hist_cols=['loss_total', 'loss_classifier', 'loss_box_reg', 'loss_objectness', 'loss_rpn_box_reg', 'score', 'area_normalized', 'area', 'bbox_ratio', 'bbox_width', 'bbox_height', 'num_annotations', 'width', 'height', 'label']
        )

        sub_tabs = pn.Tabs(
            ("Histograms", pn.Row(pn.Spacer(sizing_mode="stretch_width"), scatter_overview, pn.Spacer(sizing_mode="stretch_width"), cat_2d_hist, pn.Spacer(sizing_mode="stretch_width"), align="center")),
            ("Gallery", Gallery(self.dataset, "base_data", "filepath", sort_cols=["loss_total", "loss_classifier", "loss_box_reg", "loss_objectness", "loss_rpn_box_reg"], height=self.height).show())
        )

        return pn.Column(pn.Column(bins_input, loss_hists), sub_tabs)

    def build_ap_overview(self, metric_data):
        map_data = {key: [metric_data[key]["map"], int(len(metric_data[key].keys())-1)] for key in metric_data.keys()}
        map_table = table_from_dataframe(pd.DataFrame(map_data, index=["mAP", "Classes"]).round(4))

        ap_data = {}
        for metric_key, metric_value in metric_data.items():
            if metric_key != "map":
                ap_data[metric_key] = {"class": [], "ap": []}
                for class_name, class_data in metric_value.items():
                    if class_name != "map":
                        ap_data[metric_key]["class"].append(class_name)
                        ap_data[metric_key]["ap"].append(class_data["ap"])
        ap_plots = []
        for ap_key, ap_value in ap_data.items():
            if len(ap_value["ap"]) > 0:
                ap = np.array(ap_value["ap"])[np.array(ap_value["ap"]).argsort()]
                class_names = np.array(ap_value["class"])[np.array(ap_value["ap"]).argsort()]
                ap_plot = barplot(ap, class_names, bar_type="horizontal")
                ap_plot.add_tools(HoverTool(tooltips = [("AP", "@y @right")]))
                ap_plot.title = Title(text="mAP - " + str(metric_data[ap_key]["map"].round(4)), align="center")
                ap_plots.append(pn.Column("<b>"+ap_key.replace("_", " ").title().replace("Ap", "AP")+"</b>", ap_plot))

        return pn.Column(pn.Row(map_table, align="center"), pn.Row(*ap_plots, align="center"))

    @staticmethod
    def precision_recall_plot(data, iou):
        plot_data = pd.DataFrame({key: data[key] for key in ["recall", "precision", "scores", "tp", "fp", "fn"]})
        source = ColumnDataSource(plot_data)
        p = figure(x_axis_type=None, height=350, width=400, title="AP@"+str(iou)+" - "+str(round(data["ap"],4)), y_axis_label="precision", tools="")
        p.line("recall", "precision", source=source, legend_label="Actual", color="black", line_width=2)
        p.step(data["ap11_recalls"], data["ap11_precisions"], legend_label="AP11", color="green", line_width=2)
        p.step(data["monotonic_recalls"], data["monotonic_precisions"], legend_label="Monotonic", color="firebrick", line_width=2)
        p.add_tools(HoverTool(tooltips=[("Score", "@scores"), ("TP", "@tp"), ("FP", "@fp"), ("FN", "@fn")], mode="vline"))
        p.js_on_event(events.DoubleTap, toggle_legend_js(p))
        p.legend.click_policy="hide"
        p_score = figure(x_range=p.x_range, height=150, width=400, x_axis_label="recall", y_axis_label="score", tools="")
        p_score.scatter(data["recall"], data["scores"])
        return pn.Row(gridplot([[p],[p_score]]))

    def plot_precision_recall_curves_for_class(self, data, class_key):
        plot_list = []
        for key, value in data.items():
            if key != "ap":
                plot_list.append(self.precision_recall_plot(data[key], key))
        return plots_as_matrix(plot_list, 5, 2, width=400*5, height=500*2)

    def build_precison_recall_overview(self, data):
        if len(data) == 1:
            return pn.Column("<h1> No information available</h1>")
        class_select = pnw.Select(options=[key for key in data.keys() if key != "map"])
        @pn.depends(class_select.param.value)
        def _plot(class_name):
            heading = pn.Row("<h1>AP - "+str(data[class_name]["ap"].round(4))+"</h1>", align="center")
            table_data = {"AP": [round(data[class_name][iou_key]["ap"],4) for iou_key in data[class_name].keys() if iou_key != "ap"]}
            table_df = pd.DataFrame(table_data).T
            table_df.columns = [iou_key for iou_key in data[class_name].keys() if iou_key != "ap"]
            table_df.index.names = ["iou"]
            overview_table = table_from_dataframe(table_df)
            return pn.Column(heading, pn.Row(overview_table, align="center"), self.plot_precision_recall_curves_for_class(data[class_name], class_name))
        return pn.Column(class_select, _plot)

    def build_precision_recall_tab(self):
        overview_tab = self.build_ap_overview(self.dataset.metric_data_ap)
        ap_tab = self.build_precison_recall_overview(self.dataset.metric_data_ap["AP"])
        ap_small_tab = self.build_precison_recall_overview(self.dataset.metric_data_ap["AP_small"])
        ap_medium_tab = self.build_precison_recall_overview(self.dataset.metric_data_ap["AP_medium"])
        ap_large_tab = self.build_precison_recall_overview(self.dataset.metric_data_ap["AP_large"])

        return pn.Tabs(("Overview", overview_tab), ("AP", ap_tab), ("AP_small", ap_small_tab), ("AP_medium", ap_medium_tab), ("AP_large", ap_large_tab))